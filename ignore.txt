// ignore it

// ContentView
import Foundation
import Combine

struct ContentView : View {

@State var chatMessages : [ChatMessage] = []
@State var messageText: String = ""
@State var cancellable : = Set<Any>
var body : some View {

VStack{
ScrollView{
LazyVStack{
ForEach(chatMessages, id: \.id){ message in
messageView(message)
          }
}
}
HStack{
TextField("Ask ChatGPT", text: $messageText).padding().cornerRadius(19)
Button{
sendMessage()
} label: {
Text("Ask")
        }
      }

}.padding()
// to show messages with colors
func messageView(_ message: ChatMesssage) -> some View {
if message.sender == .me { Spacer() }
if message.sender == .gpt { Spacer() }
Text(message.content).padding().cornerRadius(11).background(message.sender==.me ? .pink : .gray).foregroundColor(message.sender==.me ? .blue : .violet)
                                                        }
    }

// sending functionality
func sendMessage(){
let mymessage = ChatMessage(id: UUID.uuidString, content: messageText, dateCreated: Date(), sender: .me)
chatMessages.append(mymessage)
openAIService.sendMessage(message: messageText).sink { completion in
//
} receiveValue: { response in
guard let textResponse = response.choices?.first.trimmingCharacters(in: .whitespacesAndNewlines.union(.init(charactersIn: "\"))) else
{ return }

let gptMessage = ChatMessage(id: UUID.uuidString, content: messageText, dateCreated: Date(), sender: .gpt)
chatMessages.append(gptMessage)

}.store(in: &cancellables)
messageText = ""
}
}
                      }

// formation of each message
struct ChatMessage {
let id : String
let content : String
let dateCreated : Date
let sender : MessageSenger
}
// message by me or response by ChatGPT
enum MessageSenger{
me
gpt
}


// Constants
// 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
import Foundation

enum Constants{
static let openAIAPIKey = "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"
}


// OpenAIService.swift
import Foundation
import Alamofire
import Combine

class OpenAIService{
let baseUrl = "https://api.openai.com/v1/completions"

func sendMesssage(message: String) -> AnyPublisher(OpenAICompletionsResponse, Error) {

let body = OpenAICompletionsBody(model: "text-davinci-003", prompt: message, temperature: 0.75, max_tokens: 255)

let headers: HTTPHeaders = [
"Authorization": "Bearer \(Constants.openAIAPIKey)"
]
return Future{ [weak,self] promise in 
guard let self = self else {return }

AF.request(self.baseUrl + "completions", method: .post, parameters: body, encoder: .json, headers: headers).responseDecodable(of: OpenAICompletionsResponse.self){ response in

switch response.result{
case .success(let result):
          promise(.success(result))
case .failure(let error):
          promise(.failure(error))
}

}
}.eraseToAnyPublisher()
}

struct OpenAICompletionsBody: Encodable {
let model: String
let prompt: String
let temperature: Float?
max_tokens: Int
}

struct OpenAICompletionsResponse: Decodable {
let id: String
let choices: [OpenAICompletionsChoices]
}

struct OpenAICompletionsChoices: Decodable{
let text: String
}
